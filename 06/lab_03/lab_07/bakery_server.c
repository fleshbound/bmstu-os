/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#define _GNU_SOURCE
#define MAX_CLIENT 40
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <stdbool.h>
#include "bakery.h"
struct thread_arg
{
	int pid;
	int num;
	int res;
};
time_t raw_time;
struct tm *timeinfo;
pthread_t threads[MAX_CLIENT];
struct thread_arg thr_res[MAX_CLIENT];
bool choosing[MAX_CLIENT] = { 0 };
int number[MAX_CLIENT] = { 0 };
int curr_res = 'a';
int local_pid = 0;
int last_num = 0;

struct BAKERY *
getn_1_svc(struct BAKERY *argp, struct svc_req *rqstp)
{
    static struct BAKERY  result;
    int i = local_pid;
    local_pid++;
    choosing[i] = true;
    int max_n = 0;
    for (int j = 0; j < MAX_CLIENT; j++)
        if (number[j] > max_n)
            max_n = number[j];
    number[i] = max_n + 1;
    result.pid = i;
    result.num = number[i];
    choosing[i] = false;
    return &result;
}

struct BAKERY *
wait_1_svc(struct BAKERY *argp, struct svc_req *rqstp)
{
    static struct BAKERY result; 
    int i = argp->pid; 
    result.pid = i; 
    result.num = argp->num; 
     
    time_t start, end;
 
    for (int j = 0; j < MAX_CLIENT; j++) { 
        while (choosing[j]);
        if (last_num > number[i])
        {
            number[i] = 0;
            result.res = '0';
            return &result;
        }
        start = clock(); 
        while ((number[j] > 0) && (number[j] < number[i] || (number[j] == number[i] && j < i))) { 
          end = clock(); 
          if ((end - start) / CLOCKS_PER_SEC > 1) { 
              break;
          } 
        } 
    } 
 
    result.res = curr_res; 
    curr_res++;  
    last_num = number[i];

    number[i] = 0; 

    for (int j = 0; j < MAX_CLIENT; j++)
        if (number[j] > 0)
            return &result;

    last_num = 0;
 
    return &result; 
}

struct BAKERY *
proc_1_svc(struct BAKERY *argp, struct svc_req *rqstp)
{
    return NULL;
}
